import * as Url from 'url-parse';
export function validateUrl(value, parseQuery) {
    const pattern = '(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?';
    const expr = new RegExp(pattern);
    if (!expr.test(value)) {
        return { url: 'Invalid URL' };
    }
    const results = new Url(value, parseQuery);
    if (!results.protocol || !results.host) {
        return { url: 'Invalid URL' };
    }
    return results;
}
/**
* Given a valid url, returns the normalized host name.
* The returned host name does not include www and is lowercase.
* The returned host includes host number.
* {} string
*/
export function normalizeHost(s, rm3w = true) {
    // Assume that s is a valid url
    const results = new Url(s);
    let h = results.host;
    if (h.startsWith('www')) {
        if (rm3w) {
            h = h.substring(4);
        }
    }
    else {
        if (!rm3w) {
            h = 'www.' + h;
        }
    }
    return h;
}
export function normalizeUrl(s, keepQuery = false, endWithSlash = false) {
    // Assume that s is a valid url
    const results = new Url(s);
    let path = results.pathname;
    path = path.replace(/\/\//g, '/');
    let u = results.protocol + '//' + results.host + path;
    if (keepQuery) {
        u = u + results.query;
    }
    if (u.endsWith('/')) {
        if (!endWithSlash) {
            u = u.substr(0, u.length - 1);
        }
    }
    else {
        if (endWithSlash) {
            u = u + '/';
        }
    }
    return u;
}
// Type predicate 
export function isInvalidSpec(v) {
    return v.url !== undefined;
}
export function buildUrlValidator(options) {
    const inputs = Object.assign({}, options);
    return function (control) {
        const value = control.value;
        const results = validateUrl(value, !!inputs.parseQuery);
        if (isInvalidSpec(results)) {
            return results;
        }
        if (inputs.https && results.protocol !== 'https') {
            return { url: 'HTTPS Required' };
        }
        return null;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLXZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtaW5wdXQtdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbImxpYi91cmwvdXJsLXZhbGlkYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQVcsQ0FBQztBQXlCakMsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFhLEVBQUUsVUFBbUI7SUFFMUQsTUFBTSxPQUFPLEdBQUcsdURBQXVELENBQUM7SUFDeEUsTUFBTSxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDbkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsQ0FBQztLQUNqQztJQUVELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQW9CLENBQUM7SUFFOUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ3BDLE9BQU8sRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLENBQUM7S0FDakM7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBR0Q7Ozs7O0VBS0U7QUFDRixNQUFNLFVBQVUsYUFBYSxDQUFDLENBQVMsRUFBRSxPQUFnQixJQUFJO0lBQ3pELCtCQUErQjtJQUMvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNyQixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLEVBQUU7WUFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtLQUNKO1NBQU07UUFDSCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEI7S0FDSjtJQUVELE9BQU8sQ0FBQyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZLENBQUMsQ0FBUyxFQUFFLFlBQXFCLEtBQUssRUFBRSxlQUF3QixLQUFLO0lBQzdGLCtCQUErQjtJQUUvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUM1QixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbEMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDdEQsSUFBSSxTQUFTLEVBQUU7UUFDWCxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7S0FDekI7SUFFRCxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDakIsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNmLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pDO0tBQ0o7U0FBTTtRQUNILElBQUksWUFBWSxFQUFFO1lBQ2QsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDZjtLQUNKO0lBRUQsT0FBTyxDQUFDLENBQUM7QUFDYixDQUFDO0FBRUQsa0JBQWtCO0FBQ2xCLE1BQU0sVUFBVSxhQUFhLENBQUMsQ0FBaUM7SUFDM0QsT0FBc0IsQ0FBRSxDQUFDLEdBQUcsS0FBSyxTQUFTLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxPQUdqQztJQUVHLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTFDLE9BQU8sVUFBUyxPQUFvQjtRQUNoQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBRTVCLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV4RCxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN4QixPQUFPLE9BQU8sQ0FBQztTQUNsQjtRQUVELElBQUksTUFBTSxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTtZQUM5QyxPQUFPLEVBQUUsR0FBRyxFQUFFLGdCQUFnQixFQUFFLENBQUM7U0FDcEM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDLENBQUM7QUFDTixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcblxyXG5pbXBvcnQgKiBhcyBVcmwgZnJvbSAndXJsLXBhcnNlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVVybFBhcnNlUmVzdWx0IHtcclxuICAgIHByb3RvY29sOiAnaHR0cCcgfCAnaHR0cHMnO1xyXG4gICAgc2xhc2hlczogYm9vbGVhbjtcclxuICAgIGF1dGg6IHN0cmluZztcclxuICAgIHVzZXJuYW1lOiBzdHJpbmc7XHJcbiAgICBwYXNzd29yZDogc3RyaW5nO1xyXG4gICAgaG9zdDogc3RyaW5nOyAgLy8gd2l0aCBwb3J0IG51bWJlciBcclxuICAgIGhvc3RuYW1lOiBzdHJpbmc7IC8vIHdpdGhvdXQgcG9ydCBudW1iZXIgXHJcbiAgICBwb3J0OiBudW1iZXI7IC8vIHBvcnQgbnVtYmVyXHJcbiAgICBwYXRobmFtZTogc3RyaW5nO1xyXG4gICAgcXVlcnk6IGFueTtcclxuICAgIGhhc2g6IHN0cmluZzsgLy8gIyBwYXJ0XHJcbiAgICBocmVmOiBzdHJpbmc7XHJcbiAgICBvcmlnaW46IHN0cmluZztcclxuXHJcbiAgICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpO1xyXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElJbnZhbGlkU3BlYyB7XHJcbiAgICB1cmw6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVXJsKHZhbHVlOiBzdHJpbmcsIHBhcnNlUXVlcnk6IGJvb2xlYW4pOiBJSW52YWxpZFNwZWMgfCBJVXJsUGFyc2VSZXN1bHQge1xyXG5cclxuICAgIGNvbnN0IHBhdHRlcm4gPSAnKGh0dHBzPzovLyk/KFtcXFxcZGEtei4tXSspXFxcXC4oW2Etei5dezIsNn0pWy9cXFxcdyAuLV0qLz8nO1xyXG4gICAgY29uc3QgZXhwciA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICBpZiAoIWV4cHIudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4geyB1cmw6ICdJbnZhbGlkIFVSTCcgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IFVybCh2YWx1ZSwgcGFyc2VRdWVyeSkgYXMgSVVybFBhcnNlUmVzdWx0O1xyXG5cclxuICAgIGlmICghcmVzdWx0cy5wcm90b2NvbCB8fCAhcmVzdWx0cy5ob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdXJsOiAnSW52YWxpZCBVUkwnIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuXHJcblxyXG4vKipcclxuKiBHaXZlbiBhIHZhbGlkIHVybCwgcmV0dXJucyB0aGUgbm9ybWFsaXplZCBob3N0IG5hbWUuIFxyXG4qIFRoZSByZXR1cm5lZCBob3N0IG5hbWUgZG9lcyBub3QgaW5jbHVkZSB3d3cgYW5kIGlzIGxvd2VyY2FzZS5cclxuKiBUaGUgcmV0dXJuZWQgaG9zdCBpbmNsdWRlcyBob3N0IG51bWJlci4gXHJcbioge30gc3RyaW5nXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVIb3N0KHM6IHN0cmluZywgcm0zdzogYm9vbGVhbiA9IHRydWUpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHMgaXMgYSB2YWxpZCB1cmxcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgVXJsKHMpIGFzIElVcmxQYXJzZVJlc3VsdDtcclxuICAgIGxldCBoID0gcmVzdWx0cy5ob3N0O1xyXG4gICAgaWYgKGguc3RhcnRzV2l0aCgnd3d3JykpIHtcclxuICAgICAgICBpZiAocm0zdykge1xyXG4gICAgICAgICAgICBoID0gaC5zdWJzdHJpbmcoNCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIXJtM3cpIHtcclxuICAgICAgICAgICAgaCA9ICd3d3cuJyArIGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplVXJsKHM6IHN0cmluZywga2VlcFF1ZXJ5OiBib29sZWFuID0gZmFsc2UsIGVuZFdpdGhTbGFzaDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCBzIGlzIGEgdmFsaWQgdXJsXHJcblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBVcmwocykgYXMgSVVybFBhcnNlUmVzdWx0O1xyXG4gICAgbGV0IHBhdGggPSByZXN1bHRzLnBhdGhuYW1lO1xyXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJyk7XHJcbiAgICBsZXQgdSA9IHJlc3VsdHMucHJvdG9jb2wgKyAnLy8nICsgcmVzdWx0cy5ob3N0ICsgcGF0aDtcclxuICAgIGlmIChrZWVwUXVlcnkpIHtcclxuICAgICAgICB1ID0gdSArIHJlc3VsdHMucXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHUuZW5kc1dpdGgoJy8nKSkge1xyXG4gICAgICAgIGlmICghZW5kV2l0aFNsYXNoKSB7XHJcbiAgICAgICAgICAgIHUgPSB1LnN1YnN0cigwLCB1Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGVuZFdpdGhTbGFzaCkge1xyXG4gICAgICAgICAgICB1ID0gdSArICcvJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHU7XHJcbn1cclxuXHJcbi8vIFR5cGUgcHJlZGljYXRlIFxyXG5leHBvcnQgZnVuY3Rpb24gaXNJbnZhbGlkU3BlYyh2OiBJVXJsUGFyc2VSZXN1bHQgfCBJSW52YWxpZFNwZWMpOiB2IGlzIElJbnZhbGlkU3BlYyB7XHJcbiAgICByZXR1cm4gKDxJSW52YWxpZFNwZWM+dikudXJsICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVybFZhbGlkYXRvcihvcHRpb25zPzoge1xyXG4gICAgaHR0cHM/OiBib29sZWFuO1xyXG4gICAgcGFyc2VRdWVyeT86IGJvb2xlYW47XHJcbn0pIHtcclxuXHJcbiAgICBjb25zdCBpbnB1dHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oY29udHJvbDogRm9ybUNvbnRyb2wpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRyb2wudmFsdWU7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB2YWxpZGF0ZVVybCh2YWx1ZSwgISFpbnB1dHMucGFyc2VRdWVyeSk7XHJcblxyXG4gICAgICAgIGlmIChpc0ludmFsaWRTcGVjKHJlc3VsdHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlucHV0cy5odHRwcyAmJiByZXN1bHRzLnByb3RvY29sICE9PSAnaHR0cHMnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVybDogJ0hUVFBTIFJlcXVpcmVkJyB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG59XHJcbiJdfQ==