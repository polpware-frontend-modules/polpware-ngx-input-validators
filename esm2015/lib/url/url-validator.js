import * as Url from 'url-parse';
export function validateUrl(value, parseQuery) {
    const pattern = '(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?';
    const expr = new RegExp(pattern);
    if (!expr.test(value)) {
        return { url: 'Invalid URL' };
    }
    const results = new Url(value, parseQuery);
    if (!results.protocol || !results.host) {
        return { url: 'Invalid URL' };
    }
    return results;
}
/**
* Given a valid url, returns the normalized host name.
* The returned host name does not include www and is lowercase.
* The returned host includes host number.
* {} string
*/
export function normalizeHost(s, rm3w = true) {
    // Assume that s is a valid url
    const results = new Url(s);
    let h = results.host;
    if (h.startsWith('www')) {
        if (rm3w) {
            h = h.substring(4);
        }
    }
    else {
        if (!rm3w) {
            h = 'www.' + h;
        }
    }
    return h;
}
export function normalizeUrl(s, keepQuery = false, endWithSlash = false) {
    // Assume that s is a valid url
    const results = new Url(s);
    let path = results.pathname;
    path = path.replace(/\/\//g, '/');
    let u = results.protocol + '//' + results.host + path;
    if (keepQuery) {
        u = u + results.query;
    }
    if (u.endsWith('/')) {
        if (!endWithSlash) {
            u = u.substr(0, u.length - 1);
        }
    }
    else {
        if (endWithSlash) {
            u = u + '/';
        }
    }
    return u;
}
// Type predicate 
export function isInvalidSpec(v) {
    return v.url !== undefined;
}
export function buildUrlValidator(options) {
    const inputs = Object.assign({}, options);
    return function (control) {
        const value = control.value;
        // Virtually true if there is no any value. 
        if (!value) {
            return null;
        }
        const results = validateUrl(value, !!inputs.parseQuery);
        if (isInvalidSpec(results)) {
            return results;
        }
        if (inputs.https && results.protocol !== 'https') {
            return { url: 'HTTPS Required' };
        }
        return null;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLXZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtaW5wdXQtdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbImxpYi91cmwvdXJsLXZhbGlkYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQVcsQ0FBQztBQXlCakMsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFhLEVBQUUsVUFBbUI7SUFFMUQsTUFBTSxPQUFPLEdBQUcsdURBQXVELENBQUM7SUFDeEUsTUFBTSxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDbkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsQ0FBQztLQUNqQztJQUVELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQW9CLENBQUM7SUFFOUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ3BDLE9BQU8sRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLENBQUM7S0FDakM7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBR0Q7Ozs7O0VBS0U7QUFDRixNQUFNLFVBQVUsYUFBYSxDQUFDLENBQVMsRUFBRSxPQUFnQixJQUFJO0lBQ3pELCtCQUErQjtJQUMvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNyQixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLEVBQUU7WUFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtLQUNKO1NBQU07UUFDSCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEI7S0FDSjtJQUVELE9BQU8sQ0FBQyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZLENBQUMsQ0FBUyxFQUFFLFlBQXFCLEtBQUssRUFBRSxlQUF3QixLQUFLO0lBQzdGLCtCQUErQjtJQUUvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUM1QixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDbEMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDdEQsSUFBSSxTQUFTLEVBQUU7UUFDWCxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7S0FDekI7SUFFRCxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDakIsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNmLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pDO0tBQ0o7U0FBTTtRQUNILElBQUksWUFBWSxFQUFFO1lBQ2QsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDZjtLQUNKO0lBRUQsT0FBTyxDQUFDLENBQUM7QUFDYixDQUFDO0FBRUQsa0JBQWtCO0FBQ2xCLE1BQU0sVUFBVSxhQUFhLENBQUMsQ0FBaUM7SUFDM0QsT0FBc0IsQ0FBRSxDQUFDLEdBQUcsS0FBSyxTQUFTLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxPQUdqQztJQUVHLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTFDLE9BQU8sVUFBUyxPQUFvQjtRQUNoQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO1FBRTVCLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUV4RCxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN4QixPQUFPLE9BQXVCLENBQUM7U0FDbEM7UUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7WUFDOUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO1NBQ3BDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5cclxuaW1wb3J0ICogYXMgVXJsIGZyb20gJ3VybC1wYXJzZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElVcmxQYXJzZVJlc3VsdCB7XHJcbiAgICBwcm90b2NvbDogJ2h0dHAnIHwgJ2h0dHBzJztcclxuICAgIHNsYXNoZXM6IGJvb2xlYW47XHJcbiAgICBhdXRoOiBzdHJpbmc7XHJcbiAgICB1c2VybmFtZTogc3RyaW5nO1xyXG4gICAgcGFzc3dvcmQ6IHN0cmluZztcclxuICAgIGhvc3Q6IHN0cmluZzsgIC8vIHdpdGggcG9ydCBudW1iZXIgXHJcbiAgICBob3N0bmFtZTogc3RyaW5nOyAvLyB3aXRob3V0IHBvcnQgbnVtYmVyIFxyXG4gICAgcG9ydDogbnVtYmVyOyAvLyBwb3J0IG51bWJlclxyXG4gICAgcGF0aG5hbWU6IHN0cmluZztcclxuICAgIHF1ZXJ5OiBhbnk7XHJcbiAgICBoYXNoOiBzdHJpbmc7IC8vICMgcGFydFxyXG4gICAgaHJlZjogc3RyaW5nO1xyXG4gICAgb3JpZ2luOiBzdHJpbmc7XHJcblxyXG4gICAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTtcclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJSW52YWxpZFNwZWMge1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVybCh2YWx1ZTogc3RyaW5nLCBwYXJzZVF1ZXJ5OiBib29sZWFuKTogSUludmFsaWRTcGVjIHwgSVVybFBhcnNlUmVzdWx0IHtcclxuXHJcbiAgICBjb25zdCBwYXR0ZXJuID0gJyhodHRwcz86Ly8pPyhbXFxcXGRhLXouLV0rKVxcXFwuKFthLXouXXsyLDZ9KVsvXFxcXHcgLi1dKi8/JztcclxuICAgIGNvbnN0IGV4cHIgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgaWYgKCFleHByLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdXJsOiAnSW52YWxpZCBVUkwnIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBVcmwodmFsdWUsIHBhcnNlUXVlcnkpIGFzIElVcmxQYXJzZVJlc3VsdDtcclxuXHJcbiAgICBpZiAoIXJlc3VsdHMucHJvdG9jb2wgfHwgIXJlc3VsdHMuaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB7IHVybDogJ0ludmFsaWQgVVJMJyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiogR2l2ZW4gYSB2YWxpZCB1cmwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgaG9zdCBuYW1lLiBcclxuKiBUaGUgcmV0dXJuZWQgaG9zdCBuYW1lIGRvZXMgbm90IGluY2x1ZGUgd3d3IGFuZCBpcyBsb3dlcmNhc2UuXHJcbiogVGhlIHJldHVybmVkIGhvc3QgaW5jbHVkZXMgaG9zdCBudW1iZXIuIFxyXG4qIHt9IHN0cmluZ1xyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSG9zdChzOiBzdHJpbmcsIHJtM3c6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCBzIGlzIGEgdmFsaWQgdXJsXHJcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IFVybChzKSBhcyBJVXJsUGFyc2VSZXN1bHQ7XHJcbiAgICBsZXQgaCA9IHJlc3VsdHMuaG9zdDtcclxuICAgIGlmIChoLnN0YXJ0c1dpdGgoJ3d3dycpKSB7XHJcbiAgICAgICAgaWYgKHJtM3cpIHtcclxuICAgICAgICAgICAgaCA9IGguc3Vic3RyaW5nKDQpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFybTN3KSB7XHJcbiAgICAgICAgICAgIGggPSAnd3d3LicgKyBoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVVybChzOiBzdHJpbmcsIGtlZXBRdWVyeTogYm9vbGVhbiA9IGZhbHNlLCBlbmRXaXRoU2xhc2g6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgcyBpcyBhIHZhbGlkIHVybFxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgVXJsKHMpIGFzIElVcmxQYXJzZVJlc3VsdDtcclxuICAgIGxldCBwYXRoID0gcmVzdWx0cy5wYXRobmFtZTtcclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpO1xyXG4gICAgbGV0IHUgPSByZXN1bHRzLnByb3RvY29sICsgJy8vJyArIHJlc3VsdHMuaG9zdCArIHBhdGg7XHJcbiAgICBpZiAoa2VlcFF1ZXJ5KSB7XHJcbiAgICAgICAgdSA9IHUgKyByZXN1bHRzLnF1ZXJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh1LmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICBpZiAoIWVuZFdpdGhTbGFzaCkge1xyXG4gICAgICAgICAgICB1ID0gdS5zdWJzdHIoMCwgdS5sZW5ndGggLSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChlbmRXaXRoU2xhc2gpIHtcclxuICAgICAgICAgICAgdSA9IHUgKyAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1O1xyXG59XHJcblxyXG4vLyBUeXBlIHByZWRpY2F0ZSBcclxuZXhwb3J0IGZ1bmN0aW9uIGlzSW52YWxpZFNwZWModjogSVVybFBhcnNlUmVzdWx0IHwgSUludmFsaWRTcGVjKTogdiBpcyBJSW52YWxpZFNwZWMge1xyXG4gICAgcmV0dXJuICg8SUludmFsaWRTcGVjPnYpLnVybCAhPT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRVcmxWYWxpZGF0b3Iob3B0aW9ucz86IHtcclxuICAgIGh0dHBzPzogYm9vbGVhbjtcclxuICAgIHBhcnNlUXVlcnk/OiBib29sZWFuO1xyXG59KSB7XHJcblxyXG4gICAgY29uc3QgaW5wdXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRyb2w6IEZvcm1Db250cm9sKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250cm9sLnZhbHVlO1xyXG5cclxuICAgICAgICAvLyBWaXJ0dWFsbHkgdHJ1ZSBpZiB0aGVyZSBpcyBubyBhbnkgdmFsdWUuIFxyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZXN1bHRzID0gdmFsaWRhdGVVcmwodmFsdWUsICEhaW5wdXRzLnBhcnNlUXVlcnkpO1xyXG5cclxuICAgICAgICBpZiAoaXNJbnZhbGlkU3BlYyhyZXN1bHRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cyBhcyBJSW52YWxpZFNwZWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5wdXRzLmh0dHBzICYmIHJlc3VsdHMucHJvdG9jb2wgIT09ICdodHRwcycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiAnSFRUUFMgUmVxdWlyZWQnIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbn1cclxuIl19