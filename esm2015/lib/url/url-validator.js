import * as Url from 'url-parse';
export function validateUrl(value, parseQuery) {
    const pattern = '(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?';
    const expr = new RegExp(pattern);
    if (!expr.test(value)) {
        return { url: 'Invalid URL' };
    }
    const results = new Url(value, parseQuery);
    if (!results.protocol || !results.host) {
        return { url: 'Invalid URL' };
    }
    return results;
}
/**
* Given a valid url, returns the normalized host name.
* The returned host name does not include www and is lowercase.
* The returned host includes host number.
* {} string
*/
export function normalizeHost(s, rm3w = true) {
    // Assume that s is a valid url
    const results = new Url(s);
    let h = results.host;
    if (h.startsWith('www')) {
        if (rm3w) {
            h = h.substring(4);
        }
    }
    else {
        if (!rm3w) {
            h = 'www.' + h;
        }
    }
    return h;
}
export function normalizeUrl(s, keepQuery = false, endWithSlash = false) {
    // Assume that s is a valid url
    const results = new Url(s);
    let path = results.pathname;
    path = path.replace(/\/\//g, '/');
    let u = results.protocol + '//' + results.host + path;
    if (keepQuery) {
        u = u + results.query;
    }
    if (u.endsWith('/')) {
        if (!endWithSlash) {
            u = u.substr(0, u.length - 1);
        }
    }
    else {
        if (endWithSlash) {
            u = u + '/';
        }
    }
    return u;
}
// Type predicate 
function isInvalidSpec(v) {
    return v.url !== undefined;
}
export function buildUrlValidator(options) {
    const inputs = Object.assign({}, options);
    return function (control) {
        const value = control.value;
        const results = validateUrl(value, !!inputs.parseQuery);
        if (isInvalidSpec(results)) {
            return results;
        }
        if (inputs.https && results.protocol !== 'https') {
            return { url: 'HTTPS Required' };
        }
        return null;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLXZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb2xwd2FyZS9uZ3gtaW5wdXQtdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbImxpYi91cmwvdXJsLXZhbGlkYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQVcsQ0FBQztBQXlCakMsTUFBTSxVQUFVLFdBQVcsQ0FBQyxLQUFhLEVBQUUsVUFBbUI7SUFFMUQsTUFBTSxPQUFPLEdBQUcsdURBQXVELENBQUM7SUFDeEUsTUFBTSxJQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDbkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsQ0FBQztLQUNqQztJQUVELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQW9CLENBQUM7SUFFOUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ3BDLE9BQU8sRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLENBQUM7S0FDakM7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNuQixDQUFDO0FBR0Q7Ozs7O0VBS0U7QUFDRixNQUFNLFVBQVUsYUFBYSxDQUFDLENBQVMsRUFBRSxPQUFnQixJQUFJO0lBQ3pELCtCQUErQjtJQUMvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztJQUNyQixJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDckIsSUFBSSxJQUFJLEVBQUU7WUFDTixDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtLQUNKO1NBQU07UUFDSCxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7U0FDbEI7S0FDSjtJQUVELE9BQU8sQ0FBQyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSxZQUFZLENBQUMsQ0FBUyxFQUFFLFlBQXFCLEtBQUssRUFBRSxlQUF3QixLQUFLO0lBQzdGLCtCQUErQjtJQUUvQixNQUFNLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQW9CLENBQUM7SUFDOUMsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQztJQUM1QixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFHLENBQUM7SUFDcEMsSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7SUFDdEQsSUFBSSxTQUFTLEVBQUU7UUFDWCxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7S0FDekI7SUFFRCxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDakIsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNmLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pDO0tBQ0o7U0FBTTtRQUNILElBQUksWUFBWSxFQUFFO1lBQ2QsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDZjtLQUNKO0lBRUQsT0FBTyxDQUFDLENBQUM7QUFDYixDQUFDO0FBRUQsa0JBQWtCO0FBQ2xCLFNBQVMsYUFBYSxDQUFDLENBQWlDO0lBQ3BELE9BQXNCLENBQUUsQ0FBQyxHQUFHLEtBQUssU0FBUyxDQUFDO0FBQy9DLENBQUM7QUFFRCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsT0FHakM7SUFFRyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUUxQyxPQUFPLFVBQVMsT0FBb0I7UUFDaEMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUU1QixNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFeEQsSUFBSSxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxPQUFPLENBQUM7U0FDbEI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7WUFDOUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO1NBQ3BDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO0FBQ04sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5cclxuaW1wb3J0ICogYXMgVXJsIGZyb20gJ3VybC1wYXJzZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElVcmxQYXJzZVJlc3VsdCB7XHJcbiAgICBwcm90b2NvbDogJ2h0dHAnIHwgJ2h0dHBzJztcclxuICAgIHNsYXNoZXM6IGJvb2xlYW47XHJcbiAgICBhdXRoOiBzdHJpbmc7XHJcbiAgICB1c2VybmFtZTogc3RyaW5nO1xyXG4gICAgcGFzc3dvcmQ6IHN0cmluZztcclxuICAgIGhvc3Q6IHN0cmluZzsgIC8vIHdpdGggcG9ydCBudW1iZXIgXHJcbiAgICBob3N0bmFtZTogc3RyaW5nOyAvLyB3aXRob3V0IHBvcnQgbnVtYmVyIFxyXG4gICAgcG9ydDogbnVtYmVyOyAvLyBwb3J0IG51bWJlclxyXG4gICAgcGF0aG5hbWU6IHN0cmluZztcclxuICAgIHF1ZXJ5OiBhbnk7XHJcbiAgICBoYXNoOiBzdHJpbmc7IC8vICMgcGFydFxyXG4gICAgaHJlZjogc3RyaW5nO1xyXG4gICAgb3JpZ2luOiBzdHJpbmc7XHJcblxyXG4gICAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTtcclxuICAgIHRvU3RyaW5nKCk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJSW52YWxpZFNwZWMge1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVybCh2YWx1ZTogc3RyaW5nLCBwYXJzZVF1ZXJ5OiBib29sZWFuKTogSUludmFsaWRTcGVjIHwgSVVybFBhcnNlUmVzdWx0IHtcclxuXHJcbiAgICBjb25zdCBwYXR0ZXJuID0gJyhodHRwcz86Ly8pPyhbXFxcXGRhLXouLV0rKVxcXFwuKFthLXouXXsyLDZ9KVsvXFxcXHcgLi1dKi8/JztcclxuICAgIGNvbnN0IGV4cHIgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgaWYgKCFleHByLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdXJsOiAnSW52YWxpZCBVUkwnIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBVcmwodmFsdWUsIHBhcnNlUXVlcnkpIGFzIElVcmxQYXJzZVJlc3VsdDtcclxuXHJcbiAgICBpZiAoIXJlc3VsdHMucHJvdG9jb2wgfHwgIXJlc3VsdHMuaG9zdCkge1xyXG4gICAgICAgIHJldHVybiB7IHVybDogJ0ludmFsaWQgVVJMJyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiogR2l2ZW4gYSB2YWxpZCB1cmwsIHJldHVybnMgdGhlIG5vcm1hbGl6ZWQgaG9zdCBuYW1lLiBcclxuKiBUaGUgcmV0dXJuZWQgaG9zdCBuYW1lIGRvZXMgbm90IGluY2x1ZGUgd3d3IGFuZCBpcyBsb3dlcmNhc2UuXHJcbiogVGhlIHJldHVybmVkIGhvc3QgaW5jbHVkZXMgaG9zdCBudW1iZXIuIFxyXG4qIHt9IHN0cmluZ1xyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSG9zdChzOiBzdHJpbmcsIHJtM3c6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAvLyBBc3N1bWUgdGhhdCBzIGlzIGEgdmFsaWQgdXJsXHJcbiAgICBjb25zdCByZXN1bHRzID0gbmV3IFVybChzKSBhcyBJVXJsUGFyc2VSZXN1bHQ7XHJcbiAgICBsZXQgaCA9IHJlc3VsdHMuaG9zdDtcclxuICAgIGlmIChoLnN0YXJ0c1dpdGgoJ3d3dycpKSB7XHJcbiAgICAgICAgaWYgKHJtM3cpIHtcclxuICAgICAgICAgICAgaCA9IGguc3Vic3RyaW5nKDQpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFybTN3KSB7XHJcbiAgICAgICAgICAgIGggPSAnd3d3LicgKyBoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVVybChzOiBzdHJpbmcsIGtlZXBRdWVyeTogYm9vbGVhbiA9IGZhbHNlLCBlbmRXaXRoU2xhc2g6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgLy8gQXNzdW1lIHRoYXQgcyBpcyBhIHZhbGlkIHVybFxyXG5cclxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgVXJsKHMpIGFzIElVcmxQYXJzZVJlc3VsdDtcclxuICAgIGxldCBwYXRoID0gcmVzdWx0cy5wYXRobmFtZTtcclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycsICk7XHJcbiAgICBsZXQgdSA9IHJlc3VsdHMucHJvdG9jb2wgKyAnLy8nICsgcmVzdWx0cy5ob3N0ICsgcGF0aDtcclxuICAgIGlmIChrZWVwUXVlcnkpIHtcclxuICAgICAgICB1ID0gdSArIHJlc3VsdHMucXVlcnk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHUuZW5kc1dpdGgoJy8nKSkge1xyXG4gICAgICAgIGlmICghZW5kV2l0aFNsYXNoKSB7XHJcbiAgICAgICAgICAgIHUgPSB1LnN1YnN0cigwLCB1Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGVuZFdpdGhTbGFzaCkge1xyXG4gICAgICAgICAgICB1ID0gdSArICcvJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHU7XHJcbn1cclxuXHJcbi8vIFR5cGUgcHJlZGljYXRlIFxyXG5mdW5jdGlvbiBpc0ludmFsaWRTcGVjKHY6IElVcmxQYXJzZVJlc3VsdCB8IElJbnZhbGlkU3BlYyk6IHYgaXMgSUludmFsaWRTcGVjIHtcclxuICAgIHJldHVybiAoPElJbnZhbGlkU3BlYz52KS51cmwgIT09IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkVXJsVmFsaWRhdG9yKG9wdGlvbnM/OiB7XHJcbiAgICBodHRwcz86IGJvb2xlYW47XHJcbiAgICBwYXJzZVF1ZXJ5PzogYm9vbGVhbjtcclxufSkge1xyXG5cclxuICAgIGNvbnN0IGlucHV0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihjb250cm9sOiBGb3JtQ29udHJvbCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29udHJvbC52YWx1ZTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHZhbGlkYXRlVXJsKHZhbHVlLCAhIWlucHV0cy5wYXJzZVF1ZXJ5KTtcclxuXHJcbiAgICAgICAgaWYgKGlzSW52YWxpZFNwZWMocmVzdWx0cykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5wdXRzLmh0dHBzICYmIHJlc3VsdHMucHJvdG9jb2wgIT09ICdodHRwcycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdXJsOiAnSFRUUFMgUmVxdWlyZWQnIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbn1cclxuIl19